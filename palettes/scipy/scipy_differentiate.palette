{
    "modelData": {
        "filePath": "scipy_differentiate.palette",
        "fileType": "Palette",
        "shortDescription": "",
        "detailedDescription": "==============================================================\nFinite Difference Differentiation (:mod:`scipy.differentiate`)\n==============================================================\n\n.. currentmodule:: scipy.differentiate\n\nSciPy ``differentiate`` provides functions for performing finite difference\nnumerical differentiation of black-box functions.\n\n.. autosummary::\n   :toctree: generated/\n\n   derivative\n   jacobian\n   hessian",
        "repoService": "",
        "repoBranch": "",
        "repo": "",
        "generatorName": "dlg_paletteGen",
        "generatorVersion": "0.6.3",
        "generatorCommitHash": "",
        "schemaVersion": "AppRef",
        "readonly": true,
        "repositoryUrl": "scipy",
        "commitHash": "0.1",
        "downloadUrl": "",
        "signature": "895295d0761cf8410df2e9ea400d9d2fc75cdfb09f608e5f2e37e350c2c2a903",
        "lastModifiedName": "wici",
        "lastModifiedEmail": "",
        "lastModifiedDatetime": 1755100436.024756,
        "numLGNodes": 3
    },
    "nodeDataArray": [
        {
            "inputAppFields": [],
            "inputApplicationDescription": "",
            "inputApplicationId": null,
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "outputAppFields": [],
            "outputApplicationDescription": "",
            "outputApplicationId": null,
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "category": "PyFuncApp",
            "categoryType": "Application",
            "id": "1diaoaxf",
            "name": "differentiate.derivative",
            "description": "Evaluate the derivative of a elementwise, real scalar function numerically.\n    \n    For each element of the output of `f`, `derivative` approximates the first\n    derivative of `f` at the corresponding element of `x` using finite difference\n    differentiation.\n    \n    This function works elementwise when `x`, `step_direction`, and `args` contain\n    (broadcastable) arrays.\n    \n    Parameters\n    ----------\n    f : callable\n        The function whose derivative is desired. The signature must be::\n    \n            f(xi: ndarray, *argsi) -> ndarray\n    \n        where each element of ``xi`` is a finite real number and ``argsi`` is a tuple,\n        which may contain an arbitrary number of arrays that are broadcastable with\n        ``xi``. `f` must be an elementwise function: each scalar element ``f(xi)[j]``\n        must equal ``f(xi[j])`` for valid indices ``j``. It must not mutate the array\n        ``xi`` or the arrays in ``argsi``.\n    x : float array_like\n        Abscissae at which to evaluate the derivative. Must be broadcastable with\n        `args` and `step_direction`.\n    args : tuple of array_like, optional\n        Additional positional array arguments to be passed to `f`. Arrays\n        must be broadcastable with one another and the arrays of `init`.\n        If the callable for which the root is desired requires arguments that are\n        not broadcastable with `x`, wrap that callable with `f` such that `f`\n        accepts only `x` and broadcastable ``*args``.\n    tolerances : dictionary of floats, optional\n        Absolute and relative tolerances. Valid keys of the dictionary are:\n    \n        - ``atol`` - absolute tolerance on the derivative\n        - ``rtol`` - relative tolerance on the derivative\n    \n        Iteration will stop when ``res.error < atol + rtol * abs(res.df)``. The default\n        `atol` is the smallest normal number of the appropriate dtype, and\n        the default `rtol` is the square root of the precision of the\n        appropriate dtype.\n    order : int, default: 8\n        The (positive integer) order of the finite difference formula to be\n        used. Odd integers will be rounded up to the next even integer.\n    initial_step : float array_like, default: 0.5\n        The (absolute) initial step size for the finite difference derivative\n        approximation.\n    step_factor : float, default: 2.0\n        The factor by which the step size is *reduced* in each iteration; i.e.\n        the step size in iteration 1 is ``initial_step/step_factor``. If\n        ``step_factor < 1``, subsequent steps will be greater than the initial\n        step; this may be useful if steps smaller than some threshold are\n        undesirable (e.g. due to subtractive cancellation error).\n    maxiter : int, default: 10\n        The maximum number of iterations of the algorithm to perform. See\n        Notes.\n    step_direction : integer array_like\n        An array representing the direction of the finite difference steps (for\n        use when `x` lies near to the boundary of the domain of the function.)\n        Must be broadcastable with `x` and all `args`.\n        Where 0 (default), central differences are used; where negative (e.g.\n        -1), steps are non-positive; and where positive (e.g. 1), all steps are\n        non-negative.\n    preserve_shape : bool, default: False\n        In the following, \"arguments of `f`\" refers to the array ``xi`` and\n        any arrays within ``argsi``. Let ``shape`` be the broadcasted shape\n        of `x` and all elements of `args` (which is conceptually\n        distinct from ``xi` and ``argsi`` passed into `f`).\n    \n        - When ``preserve_shape=False`` (default), `f` must accept arguments\n          of *any* broadcastable shapes.\n    \n        - When ``preserve_shape=True``, `f` must accept arguments of shape\n          ``shape`` *or* ``shape + (n,)``, where ``(n,)`` is the number of\n          abscissae at which the function is being evaluated.\n    \n        In either case, for each scalar element ``xi[j]`` within ``xi``, the array\n        returned by `f` must include the scalar ``f(xi[j])`` at the same index.\n        Consequently, the shape of the output is always the shape of the input\n        ``xi``.\n    \n        See Examples.\n    callback : callable, optional\n        An optional user-supplied function to be called before the first\n        iteration and after each iteration.\n        Called as ``callback(res)``, where ``res`` is a ``_RichResult``\n        similar to that returned by `derivative` (but containing the current\n        iterate's values of all variables). If `callback` raises a\n        ``StopIteration``, the algorithm will terminate immediately and\n        `derivative` will return a result. `callback` must not mutate\n        `res` or its attributes.\n    \n    Returns\n    -------\n    res : _RichResult\n        An object similar to an instance of `scipy.optimize.OptimizeResult` with the\n        following attributes. The descriptions are written as though the values will\n        be scalars; however, if `f` returns an array, the outputs will be\n        arrays of the same shape.\n    \n        success : bool array\n            ``True`` where the algorithm terminated successfully (status ``0``);\n            ``False`` otherwise.\n        status : int array\n            An integer representing the exit status of the algorithm.\n    \n            - ``0`` : The algorithm converged to the specified tolerances.\n            - ``-1`` : The error estimate increased, so iteration was terminated.\n            - ``-2`` : The maximum number of iterations was reached.\n            - ``-3`` : A non-finite value was encountered.\n            - ``-4`` : Iteration was terminated by `callback`.\n            - ``1`` : The algorithm is proceeding normally (in `callback` only).\n    \n        df : float array\n            The derivative of `f` at `x`, if the algorithm terminated\n            successfully.\n        error : float array\n            An estimate of the error: the magnitude of the difference between\n            the current estimate of the derivative and the estimate in the\n            previous iteration.\n        nit : int array\n            The number of iterations of the algorithm that were performed.\n        nfev : int array\n            The number of points at which `f` was evaluated.\n        x : float array\n            The value at which the derivative of `f` was evaluated\n            (after broadcasting with `args` and `step_direction`).\n    \n    See Also\n    --------\n    jacobian, hessian\n    \n    Notes\n    -----\n    The implementation was inspired by jacobi [1]_, numdifftools [2]_, and\n    DERIVEST [3]_, but the implementation follows the theory of Taylor series\n    more straightforwardly (and arguably naively so).\n    In the first iteration, the derivative is estimated using a finite\n    difference formula of order `order` with maximum step size `initial_step`.\n    Each subsequent iteration, the maximum step size is reduced by\n    `step_factor`, and the derivative is estimated again until a termination\n    condition is reached. The error estimate is the magnitude of the difference\n    between the current derivative approximation and that of the previous\n    iteration.\n    \n    The stencils of the finite difference formulae are designed such that\n    abscissae are \"nested\": after `f` is evaluated at ``order + 1``\n    points in the first iteration, `f` is evaluated at only two new points\n    in each subsequent iteration; ``order - 1`` previously evaluated function\n    values required by the finite difference formula are reused, and two\n    function values (evaluations at the points furthest from `x`) are unused.\n    \n    Step sizes are absolute. When the step size is small relative to the\n    magnitude of `x`, precision is lost; for example, if `x` is ``1e20``, the\n    default initial step size of ``0.5`` cannot be resolved. Accordingly,\n    consider using larger initial step sizes for large magnitudes of `x`.\n    \n    The default tolerances are challenging to satisfy at points where the\n    true derivative is exactly zero. If the derivative may be exactly zero,\n    consider specifying an absolute tolerance (e.g. ``atol=1e-12``) to\n    improve convergence.\n    \n    References\n    ----------\n    .. [1] Hans Dembinski (@HDembinski). jacobi.\n           https://github.com/HDembinski/jacobi\n    .. [2] Per A. Brodtkorb and John D'Errico. numdifftools.\n           https://numdifftools.readthedocs.io/en/latest/\n    .. [3] John D'Errico. DERIVEST: Adaptive Robust Numerical Differentiation.\n           https://www.mathworks.com/matlabcentral/fileexchange/13490-adaptive-robust-numerical-differentiation\n    .. [4] Numerical Differentition. Wikipedia.\n           https://en.wikipedia.org/wiki/Numerical_differentiation\n    \n    Examples\n    --------\n    Evaluate the derivative of ``np.exp`` at several points ``x``.\n    \n    >>> import numpy as np\n    >>> from scipy.differentiate import derivative\n    >>> f = np.exp\n    >>> df = np.exp  # true derivative\n    >>> x = np.linspace(1, 2, 5)\n    >>> res = derivative(f, x)\n    >>> res.df  # approximation of the derivative\n    array([2.71828183, 3.49034296, 4.48168907, 5.75460268, 7.3890561 ])\n    >>> res.error  # estimate of the error\n    array([7.13740178e-12, 9.16600129e-12, 1.17594823e-11, 1.51061386e-11,\n           1.94262384e-11])\n    >>> abs(res.df - df(x))  # true error\n    array([2.53130850e-14, 3.55271368e-14, 5.77315973e-14, 5.59552404e-14,\n           6.92779167e-14])\n    \n    Show the convergence of the approximation as the step size is reduced.\n    Each iteration, the step size is reduced by `step_factor`, so for\n    sufficiently small initial step, each iteration reduces the error by a\n    factor of ``1/step_factor**order`` until finite precision arithmetic\n    inhibits further improvement.\n    \n    >>> import matplotlib.pyplot as plt\n    >>> iter = list(range(1, 12))  # maximum iterations\n    >>> hfac = 2  # step size reduction per iteration\n    >>> hdir = [-1, 0, 1]  # compare left-, central-, and right- steps\n    >>> order = 4  # order of differentiation formula\n    >>> x = 1\n    >>> ref = df(x)\n    >>> errors = []  # true error\n    >>> for i in iter:\n    ...     res = derivative(f, x, maxiter=i, step_factor=hfac,\n    ...                      step_direction=hdir, order=order,\n    ...                      # prevent early termination\n    ...                      tolerances=dict(atol=0, rtol=0))\n    ...     errors.append(abs(res.df - ref))\n    >>> errors = np.array(errors)\n    >>> plt.semilogy(iter, errors[:, 0], label='left differences')\n    >>> plt.semilogy(iter, errors[:, 1], label='central differences')\n    >>> plt.semilogy(iter, errors[:, 2], label='right differences')\n    >>> plt.xlabel('iteration')\n    >>> plt.ylabel('error')\n    >>> plt.legend()\n    >>> plt.show()\n    >>> (errors[1, 1] / errors[0, 1], 1 / hfac**order)\n    (0.06215223140159822, 0.0625)\n    \n    The implementation is vectorized over `x`, `step_direction`, and `args`.\n    The function is evaluated once before the first iteration to perform input\n    validation and standardization, and once per iteration thereafter.\n    \n    >>> def f(x, p):\n    ...     f.nit += 1\n    ...     return x**p\n    >>> f.nit = 0\n    >>> def df(x, p):\n    ...     return p*x**(p-1)\n    >>> x = np.arange(1, 5)\n    >>> p = np.arange(1, 6).reshape((-1, 1))\n    >>> hdir = np.arange(-1, 2).reshape((-1, 1, 1))\n    >>> res = derivative(f, x, args=(p,), step_direction=hdir, maxiter=1)\n    >>> np.allclose(res.df, df(x, p))\n    True\n    >>> res.df.shape\n    (3, 5, 4)\n    >>> f.nit\n    2\n    \n    By default, `preserve_shape` is False, and therefore the callable\n    `f` may be called with arrays of any broadcastable shapes.\n    For example:\n    \n    >>> shapes = []\n    >>> def f(x, c):\n    ...    shape = np.broadcast_shapes(x.shape, c.shape)\n    ...    shapes.append(shape)\n    ...    return np.sin(c*x)\n    >>>\n    >>> c = [1, 5, 10, 20]\n    >>> res = derivative(f, 0, args=(c,))\n    >>> shapes\n    [(4,), (4, 8), (4, 2), (3, 2), (2, 2), (1, 2)]\n    \n    To understand where these shapes are coming from - and to better\n    understand how `derivative` computes accurate results - note that\n    higher values of ``c`` correspond with higher frequency sinusoids.\n    The higher frequency sinusoids make the function's derivative change\n    faster, so more function evaluations are required to achieve the target\n    accuracy:\n    \n    >>> res.nfev\n    array([11, 13, 15, 17], dtype=int32)\n    \n    The initial ``shape``, ``(4,)``, corresponds with evaluating the\n    function at a single abscissa and all four frequencies; this is used\n    for input validation and to determine the size and dtype of the arrays\n    that store results. The next shape corresponds with evaluating the\n    function at an initial grid of abscissae and all four frequencies.\n    Successive calls to the function evaluate the function at two more\n    abscissae, increasing the effective order of the approximation by two.\n    However, in later function evaluations, the function is evaluated at\n    fewer frequencies because the corresponding derivative has already\n    converged to the required tolerance. This saves function evaluations to\n    improve performance, but it requires the function to accept arguments of\n    any shape.\n    \n    \"Vector-valued\" functions are unlikely to satisfy this requirement.\n    For example, consider\n    \n    >>> def f(x):\n    ...    return [x, np.sin(3*x), x+np.sin(10*x), np.sin(20*x)*(x-1)**2]\n    \n    This integrand is not compatible with `derivative` as written; for instance,\n    the shape of the output will not be the same as the shape of ``x``. Such a\n    function *could* be converted to a compatible form with the introduction of\n    additional parameters, but this would be inconvenient. In such cases,\n    a simpler solution would be to use `preserve_shape`.\n    \n    >>> shapes = []\n    >>> def f(x):\n    ...     shapes.append(x.shape)\n    ...     x0, x1, x2, x3 = x\n    ...     return [x0, np.sin(3*x1), x2+np.sin(10*x2), np.sin(20*x3)*(x3-1)**2]\n    >>>\n    >>> x = np.zeros(4)\n    >>> res = derivative(f, x, preserve_shape=True)\n    >>> shapes\n    [(4,), (4, 8), (4, 2), (4, 2), (4, 2), (4, 2)]\n    \n    Here, the shape of ``x`` is ``(4,)``. With ``preserve_shape=True``, the\n    function may be called with argument ``x`` of shape ``(4,)`` or ``(4, n)``,\n    and this is what we observe.",
            "repositoryUrl": "dlg_paletteGen.generated",
            "commitHash": "0.1",
            "paletteDownloadUrl": "",
            "dataHash": "df98a541a9290c810f222250479a023b4745e7db960917a8228cff912f1ec70b",
            "fields": [
                {
                    "id": "7n691wx8",
                    "encoding": "",
                    "name": "f",
                    "value": "",
                    "defaultValue": "",
                    "description": "The function whose derivative is desired. The signature must be::\n\n    f(xi: ndarray, *argsi) -> ndarray\n\nwhere each element of ``xi`` is a finite real number and ``argsi`` is a tuple,\nwhich may contain an arbitrary number of arrays that are broadcastable with\n``xi``. `f` must be an elementwise function: each scalar element ``f(xi)[j]``\nmust equal ``f(xi[j])`` for valid indices ``j``. It must not mutate the array\n``xi`` or the arrays in ``argsi``.",
                    "type": "callable",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "wyxfiy_m",
                    "encoding": "",
                    "name": "x",
                    "value": "",
                    "defaultValue": "",
                    "description": "Abscissae at which to evaluate the derivative. Must be broadcastable with\n`args` and `step_direction`.",
                    "type": "float arraylike",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "p6kjgndq",
                    "encoding": "",
                    "name": "args",
                    "value": "builtins.tuple",
                    "defaultValue": "builtins.tuple",
                    "description": "Additional positional array arguments to be passed to `f`. Arrays\nmust be broadcastable with one another and the arrays of `init`.\nIf the callable for which the root is desired requires arguments that are\nnot broadcastable with `x`, wrap that callable with `f` such that `f`\naccepts only `x` and broadcastable ``*args``.",
                    "type": "List",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "em8cr33a",
                    "encoding": "",
                    "name": "tolerances",
                    "value": "",
                    "defaultValue": "",
                    "description": "Absolute and relative tolerances. Valid keys of the dictionary are:\n\n- ``atol`` - absolute tolerance on the derivative\n- ``rtol`` - relative tolerance on the derivative\n\nIteration will stop when ``res.error < atol + rtol * abs(res.df)``. The default\n`atol` is the smallest normal number of the appropriate dtype, and\nthe default `rtol` is the square root of the precision of the\nappropriate dtype.",
                    "type": "dictionary of floats",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "79v7_2l5",
                    "encoding": "",
                    "name": "maxiter",
                    "value": 10,
                    "defaultValue": 10,
                    "description": "The maximum number of iterations of the algorithm to perform. See\nNotes.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "9z8f2cm1",
                    "encoding": "",
                    "name": "order",
                    "value": 8,
                    "defaultValue": 8,
                    "description": "The (positive integer) order of the finite difference formula to be\nused. Odd integers will be rounded up to the next even integer.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "l_mivxsj",
                    "encoding": "",
                    "name": "initial_step",
                    "value": 0.5,
                    "defaultValue": 0.5,
                    "description": "The (absolute) initial step size for the finite difference derivative\napproximation.",
                    "type": "float",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "gsev51y4",
                    "encoding": "",
                    "name": "step_factor",
                    "value": 2.0,
                    "defaultValue": 2.0,
                    "description": "The factor by which the step size is *reduced* in each iteration; i.e.\nthe step size in iteration 1 is ``initial_step/step_factor``. If\n``step_factor < 1``, subsequent steps will be greater than the initial\nstep; this may be useful if steps smaller than some threshold are\nundesirable (e.g. due to subtractive cancellation error).",
                    "type": "float",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "3uijlmh2",
                    "encoding": "",
                    "name": "step_direction",
                    "value": 0,
                    "defaultValue": 0,
                    "description": "An array representing the direction of the finite difference steps (for\nuse when `x` lies near to the boundary of the domain of the function.)\nMust be broadcastable with `x` and all `args`.\nWhere 0 (default), central differences are used; where negative (e.g.\n-1), steps are non-positive; and where positive (e.g. 1), all steps are\nnon-negative.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "01w7jn49",
                    "encoding": "",
                    "name": "preserve_shape",
                    "value": false,
                    "defaultValue": false,
                    "description": "In the following, \"arguments of `f`\" refers to the array ``xi`` and\nany arrays within ``argsi``. Let ``shape`` be the broadcasted shape\nof `x` and all elements of `args` (which is conceptually\ndistinct from ``xi` and ``argsi`` passed into `f`).\n\n- When ``preserve_shape=False`` (default), `f` must accept arguments\n  of *any* broadcastable shapes.\n\n- When ``preserve_shape=True``, `f` must accept arguments of shape\n  ``shape`` *or* ``shape + (n,)``, where ``(n,)`` is the number of\n  abscissae at which the function is being evaluated.\n\nIn either case, for each scalar element ``xi[j]`` within ``xi``, the array\nreturned by `f` must include the scalar ``f(xi[j])`` at the same index.\nConsequently, the shape of the output is always the shape of the input\n``xi``.\n\nSee Examples.",
                    "type": "bool",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "h_x45cr6",
                    "encoding": "",
                    "name": "callback",
                    "value": "",
                    "defaultValue": "",
                    "description": "An optional user-supplied function to be called before the first\niteration and after each iteration.\nCalled as ``callback(res)``, where ``res`` is a ``_RichResult``\nsimilar to that returned by `derivative` (but containing the current\niterate's values of all variables). If `callback` raises a\n``StopIteration``, the algorithm will terminate immediately and\n`derivative` will return a result. `callback` must not mutate\n`res` or its attributes.",
                    "type": "callable",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "n0e3qdyr",
                    "encoding": "",
                    "name": "func_name",
                    "value": "scipy.differentiate.derivative",
                    "defaultValue": "scipy.differentiate.derivative",
                    "description": "Complete import path of function or just a function name which is also used in func_code below.",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "qe8zjyqr",
                    "encoding": "",
                    "name": "log-level",
                    "value": "NOTSET",
                    "defaultValue": "NOTSET",
                    "description": "Log-level to be used for this appplication. If empty or NOTSET, the global setting will be used.",
                    "type": "Select",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [
                        "NOTSET",
                        "DEBUG",
                        "INFO",
                        "WARNING",
                        "ERROR",
                        "CRITICAL"
                    ],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "0vpbd1v9",
                    "encoding": "",
                    "name": "group_start",
                    "value": false,
                    "defaultValue": null,
                    "description": "Is this node the start of a group?",
                    "type": "Boolean",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false,
                    "default_value": false
                },
                {
                    "id": "6ciudjxn",
                    "encoding": "",
                    "name": "dropclass",
                    "value": "dlg.apps.pyfunc.PyFuncApp",
                    "defaultValue": "dlg.apps.pyfunc.PyFuncApp",
                    "description": "The python class that implements this application",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "44_4y72p",
                    "encoding": "",
                    "name": "base_name",
                    "value": "scipy.differentiate",
                    "defaultValue": "scipy.differentiate",
                    "description": "The base class for this member function.",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "ryx6w761",
                    "encoding": "",
                    "name": "execution_time",
                    "value": 2,
                    "defaultValue": 2,
                    "description": "Estimate of execution time (in seconds) for this application.",
                    "type": "Integer",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "kcuv0g5v",
                    "encoding": "",
                    "name": "num_cpus",
                    "value": 1,
                    "defaultValue": 1,
                    "description": "Number of cores used.",
                    "type": "Integer",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                }
            ]
        },
        {
            "inputAppFields": [],
            "inputApplicationDescription": "",
            "inputApplicationId": null,
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "outputAppFields": [],
            "outputApplicationDescription": "",
            "outputApplicationId": null,
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "category": "PyFuncApp",
            "categoryType": "Application",
            "id": "i3i4s4wp",
            "name": "differentiate.hessian",
            "description": "Evaluate the Hessian of a function numerically.\n    \n    Parameters\n    ----------\n    f : callable\n        The function whose Hessian is desired. The signature must be::\n    \n            f(xi: ndarray) -> ndarray\n    \n        where each element of ``xi`` is a finite real. If the function to be\n        differentiated accepts additional arguments, wrap it (e.g. using\n        `functools.partial` or ``lambda``) and pass the wrapped callable\n        into `hessian`. `f` must not mutate the array ``xi``. See Notes\n        regarding vectorization and the dimensionality of the input and output.\n    x : float array_like\n        Points at which to evaluate the Hessian. Must have at least one dimension.\n        See Notes regarding the dimensionality and vectorization.\n    tolerances : dictionary of floats, optional\n        Absolute and relative tolerances. Valid keys of the dictionary are:\n    \n        - ``atol`` - absolute tolerance on the derivative\n        - ``rtol`` - relative tolerance on the derivative\n    \n        Iteration will stop when ``res.error < atol + rtol * abs(res.df)``. The default\n        `atol` is the smallest normal number of the appropriate dtype, and\n        the default `rtol` is the square root of the precision of the\n        appropriate dtype.\n    order : int, default: 8\n        The (positive integer) order of the finite difference formula to be\n        used. Odd integers will be rounded up to the next even integer.\n    initial_step : float, default: 0.5\n        The (absolute) initial step size for the finite difference derivative\n        approximation.\n    step_factor : float, default: 2.0\n        The factor by which the step size is *reduced* in each iteration; i.e.\n        the step size in iteration 1 is ``initial_step/step_factor``. If\n        ``step_factor < 1``, subsequent steps will be greater than the initial\n        step; this may be useful if steps smaller than some threshold are\n        undesirable (e.g. due to subtractive cancellation error).\n    maxiter : int, default: 10\n        The maximum number of iterations of the algorithm to perform. See\n        Notes.\n    \n    Returns\n    -------\n    res : _RichResult\n        An object similar to an instance of `scipy.optimize.OptimizeResult` with the\n        following attributes. The descriptions are written as though the values will\n        be scalars; however, if `f` returns an array, the outputs will be\n        arrays of the same shape.\n    \n        success : bool array\n            ``True`` where the algorithm terminated successfully (status ``0``);\n            ``False`` otherwise.\n        status : int array\n            An integer representing the exit status of the algorithm.\n    \n            - ``0`` : The algorithm converged to the specified tolerances.\n            - ``-1`` : The error estimate increased, so iteration was terminated.\n            - ``-2`` : The maximum number of iterations was reached.\n            - ``-3`` : A non-finite value was encountered.\n    \n        ddf : float array\n            The Hessian of `f` at `x`, if the algorithm terminated\n            successfully.\n        error : float array\n            An estimate of the error: the magnitude of the difference between\n            the current estimate of the Hessian and the estimate in the\n            previous iteration.\n        nfev : int array\n            The number of points at which `f` was evaluated.\n    \n        Each element of an attribute is associated with the corresponding\n        element of `ddf`. For instance, element ``[i, j]`` of `nfev` is the\n        number of points at which `f` was evaluated for the sake of\n        computing element ``[i, j]`` of `ddf`.\n    \n    See Also\n    --------\n    derivative, jacobian\n    \n    Notes\n    -----\n    Suppose we wish to evaluate the Hessian of a function\n    :math:`f: \\mathbf{R}^m \\rightarrow \\mathbf{R}`, and we assign to variable\n    ``m`` the positive integer value of :math:`m`. If we wish to evaluate\n    the Hessian at a single point, then:\n    \n    - argument `x` must be an array of shape ``(m,)``\n    - argument `f` must be vectorized to accept an array of shape\n      ``(m, ...)``. The first axis represents the :math:`m` inputs of\n      :math:`f`; the remaining axes indicated by ellipses are for evaluating\n      the function at several abscissae in a single call.\n    - argument `f` must return an array of shape ``(...)``.\n    - attribute ``dff`` of the result object will be an array of shape ``(m, m)``,\n      the Hessian.\n    \n    This function is also vectorized in the sense that the Hessian can be\n    evaluated at ``k`` points in a single call. In this case, `x` would be an\n    array of shape ``(m, k)``, `f` would accept an array of shape\n    ``(m, ...)`` and return an array of shape ``(...)``, and the ``ddf``\n    attribute of the result would have shape ``(m, m, k)``. Note that the\n    axis associated with the ``k`` points is included within the axes\n    denoted by ``(...)``.\n    \n    Currently, `hessian` is implemented by nesting calls to `jacobian`.\n    All options passed to `hessian` are used for both the inner and outer\n    calls with one exception: the `rtol` used in the inner `jacobian` call\n    is tightened by a factor of 100 with the expectation that the inner\n    error can be ignored. A consequence is that `rtol` should not be set\n    less than 100 times the precision of the dtype of `x`; a warning is\n    emitted otherwise.\n    \n    References\n    ----------\n    .. [1] Hessian matrix, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Hessian_matrix\n    \n    Examples\n    --------\n    The Rosenbrock function maps from :math:`\\mathbf{R}^m \\rightarrow \\mathbf{R}`;\n    the SciPy implementation `scipy.optimize.rosen` is vectorized to accept an\n    array of shape ``(m, ...)`` and return an array of shape ``...``. Suppose we\n    wish to evaluate the Hessian at ``[0.5, 0.5, 0.5]``.\n    \n    >>> import numpy as np\n    >>> from scipy.differentiate import hessian\n    >>> from scipy.optimize import rosen, rosen_hess\n    >>> m = 3\n    >>> x = np.full(m, 0.5)\n    >>> res = hessian(rosen, x)\n    >>> ref = rosen_hess(x)  # reference value of the Hessian\n    >>> np.allclose(res.ddf, ref)\n    True\n    \n    `hessian` is vectorized to evaluate the Hessian at multiple points\n    in a single call.\n    \n    >>> rng = np.random.default_rng(4589245925010)\n    >>> x = rng.random((m, 10))\n    >>> res = hessian(rosen, x)\n    >>> ref = [rosen_hess(xi) for xi in x.T]\n    >>> ref = np.moveaxis(ref, 0, -1)\n    >>> np.allclose(res.ddf, ref)\n    True",
            "repositoryUrl": "dlg_paletteGen.generated",
            "commitHash": "0.1",
            "paletteDownloadUrl": "",
            "dataHash": "43fccd472aa3838e9eac0c505a7d4a0575eb0be7553da0265dfee7dd40e32ed2",
            "fields": [
                {
                    "id": "1lxt4ihz",
                    "encoding": "",
                    "name": "f",
                    "value": "",
                    "defaultValue": "",
                    "description": "The function whose Hessian is desired. The signature must be::\n\n    f(xi: ndarray) -> ndarray\n\nwhere each element of ``xi`` is a finite real. If the function to be\ndifferentiated accepts additional arguments, wrap it (e.g. using\n`functools.partial` or ``lambda``) and pass the wrapped callable\ninto `hessian`. `f` must not mutate the array ``xi``. See Notes\nregarding vectorization and the dimensionality of the input and output.",
                    "type": "callable",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "yl8l23np",
                    "encoding": "",
                    "name": "x",
                    "value": "",
                    "defaultValue": "",
                    "description": "Points at which to evaluate the Hessian. Must have at least one dimension.\nSee Notes regarding the dimensionality and vectorization.",
                    "type": "float arraylike",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "97bbxl_7",
                    "encoding": "",
                    "name": "tolerances",
                    "value": "",
                    "defaultValue": "",
                    "description": "Absolute and relative tolerances. Valid keys of the dictionary are:\n\n- ``atol`` - absolute tolerance on the derivative\n- ``rtol`` - relative tolerance on the derivative\n\nIteration will stop when ``res.error < atol + rtol * abs(res.df)``. The default\n`atol` is the smallest normal number of the appropriate dtype, and\nthe default `rtol` is the square root of the precision of the\nappropriate dtype.",
                    "type": "dictionary of floats",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "igxxf4oi",
                    "encoding": "",
                    "name": "maxiter",
                    "value": 10,
                    "defaultValue": 10,
                    "description": "The maximum number of iterations of the algorithm to perform. See\nNotes.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "7dumncyu",
                    "encoding": "",
                    "name": "order",
                    "value": 8,
                    "defaultValue": 8,
                    "description": "The (positive integer) order of the finite difference formula to be\nused. Odd integers will be rounded up to the next even integer.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "he7vugb3",
                    "encoding": "",
                    "name": "initial_step",
                    "value": 0.5,
                    "defaultValue": 0.5,
                    "description": "The (absolute) initial step size for the finite difference derivative\napproximation.",
                    "type": "float",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "n3deqct8",
                    "encoding": "",
                    "name": "step_factor",
                    "value": 2.0,
                    "defaultValue": 2.0,
                    "description": "The factor by which the step size is *reduced* in each iteration; i.e.\nthe step size in iteration 1 is ``initial_step/step_factor``. If\n``step_factor < 1``, subsequent steps will be greater than the initial\nstep; this may be useful if steps smaller than some threshold are\nundesirable (e.g. due to subtractive cancellation error).",
                    "type": "float",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "6el27429",
                    "encoding": "",
                    "name": "func_name",
                    "value": "scipy.differentiate.hessian",
                    "defaultValue": "scipy.differentiate.hessian",
                    "description": "Complete import path of function or just a function name which is also used in func_code below.",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "5vro1ca2",
                    "encoding": "",
                    "name": "log-level",
                    "value": "NOTSET",
                    "defaultValue": "NOTSET",
                    "description": "Log-level to be used for this appplication. If empty or NOTSET, the global setting will be used.",
                    "type": "Select",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [
                        "NOTSET",
                        "DEBUG",
                        "INFO",
                        "WARNING",
                        "ERROR",
                        "CRITICAL"
                    ],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "anpwja6u",
                    "encoding": "",
                    "name": "group_start",
                    "value": false,
                    "defaultValue": null,
                    "description": "Is this node the start of a group?",
                    "type": "Boolean",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false,
                    "default_value": false
                },
                {
                    "id": "fwgi61c0",
                    "encoding": "",
                    "name": "dropclass",
                    "value": "dlg.apps.pyfunc.PyFuncApp",
                    "defaultValue": "dlg.apps.pyfunc.PyFuncApp",
                    "description": "The python class that implements this application",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "om57i8_k",
                    "encoding": "",
                    "name": "base_name",
                    "value": "scipy.differentiate",
                    "defaultValue": "scipy.differentiate",
                    "description": "The base class for this member function.",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "conwpyi6",
                    "encoding": "",
                    "name": "execution_time",
                    "value": 2,
                    "defaultValue": 2,
                    "description": "Estimate of execution time (in seconds) for this application.",
                    "type": "Integer",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "qd59bew6",
                    "encoding": "",
                    "name": "num_cpus",
                    "value": 1,
                    "defaultValue": 1,
                    "description": "Number of cores used.",
                    "type": "Integer",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                }
            ]
        },
        {
            "inputAppFields": [],
            "inputApplicationDescription": "",
            "inputApplicationId": null,
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "outputAppFields": [],
            "outputApplicationDescription": "",
            "outputApplicationId": null,
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "category": "PyFuncApp",
            "categoryType": "Application",
            "id": "qbkvfe_m",
            "name": "differentiate.jacobian",
            "description": "Evaluate the Jacobian of a function numerically.\n    \n    Parameters\n    ----------\n    f : callable\n        The function whose Jacobian is desired. The signature must be::\n    \n            f(xi: ndarray) -> ndarray\n    \n        where each element of ``xi`` is a finite real. If the function to be\n        differentiated accepts additional arguments, wrap it (e.g. using\n        `functools.partial` or ``lambda``) and pass the wrapped callable\n        into `jacobian`. `f` must not mutate the array ``xi``. See Notes\n        regarding vectorization and the dimensionality of the input and output.\n    x : float array_like\n        Points at which to evaluate the Jacobian. Must have at least one dimension.\n        See Notes regarding the dimensionality and vectorization.\n    tolerances : dictionary of floats, optional\n        Absolute and relative tolerances. Valid keys of the dictionary are:\n    \n        - ``atol`` - absolute tolerance on the derivative\n        - ``rtol`` - relative tolerance on the derivative\n    \n        Iteration will stop when ``res.error < atol + rtol * abs(res.df)``. The default\n        `atol` is the smallest normal number of the appropriate dtype, and\n        the default `rtol` is the square root of the precision of the\n        appropriate dtype.\n    maxiter : int, default: 10\n        The maximum number of iterations of the algorithm to perform. See\n        Notes.\n    order : int, default: 8\n        The (positive integer) order of the finite difference formula to be\n        used. Odd integers will be rounded up to the next even integer.\n    initial_step : float array_like, default: 0.5\n        The (absolute) initial step size for the finite difference derivative\n        approximation. Must be broadcastable with `x` and `step_direction`.\n    step_factor : float, default: 2.0\n        The factor by which the step size is *reduced* in each iteration; i.e.\n        the step size in iteration 1 is ``initial_step/step_factor``. If\n        ``step_factor < 1``, subsequent steps will be greater than the initial\n        step; this may be useful if steps smaller than some threshold are\n        undesirable (e.g. due to subtractive cancellation error).\n    step_direction : integer array_like\n        An array representing the direction of the finite difference steps (e.g.\n        for use when `x` lies near to the boundary of the domain of the function.)\n        Must be broadcastable with `x` and `initial_step`.\n        Where 0 (default), central differences are used; where negative (e.g.\n        -1), steps are non-positive; and where positive (e.g. 1), all steps are\n        non-negative.\n    \n    Returns\n    -------\n    res : _RichResult\n        An object similar to an instance of `scipy.optimize.OptimizeResult` with the\n        following attributes. The descriptions are written as though the values will\n        be scalars; however, if `f` returns an array, the outputs will be\n        arrays of the same shape.\n    \n        success : bool array\n            ``True`` where the algorithm terminated successfully (status ``0``);\n            ``False`` otherwise.\n        status : int array\n            An integer representing the exit status of the algorithm.\n    \n            - ``0`` : The algorithm converged to the specified tolerances.\n            - ``-1`` : The error estimate increased, so iteration was terminated.\n            - ``-2`` : The maximum number of iterations was reached.\n            - ``-3`` : A non-finite value was encountered.\n    \n        df : float array\n            The Jacobian of `f` at `x`, if the algorithm terminated\n            successfully.\n        error : float array\n            An estimate of the error: the magnitude of the difference between\n            the current estimate of the Jacobian and the estimate in the\n            previous iteration.\n        nit : int array\n            The number of iterations of the algorithm that were performed.\n        nfev : int array\n            The number of points at which `f` was evaluated.\n    \n        Each element of an attribute is associated with the corresponding\n        element of `df`. For instance, element ``i`` of `nfev` is the\n        number of points at which `f` was evaluated for the sake of\n        computing element ``i`` of `df`.\n    \n    See Also\n    --------\n    derivative, hessian\n    \n    Notes\n    -----\n    Suppose we wish to evaluate the Jacobian of a function\n    :math:`f: \\mathbf{R}^m \\rightarrow \\mathbf{R}^n`. Assign to variables\n    ``m`` and ``n`` the positive integer values of :math:`m` and :math:`n`,\n    respectively, and let ``...`` represent an arbitrary tuple of integers.\n    If we wish to evaluate the Jacobian at a single point, then:\n    \n    - argument `x` must be an array of shape ``(m,)``\n    - argument `f` must be vectorized to accept an array of shape ``(m, ...)``.\n      The first axis represents the :math:`m` inputs of :math:`f`; the remainder\n      are for evaluating the function at multiple points in a single call.\n    - argument `f` must return an array of shape ``(n, ...)``. The first\n      axis represents the :math:`n` outputs of :math:`f`; the remainder\n      are for the result of evaluating the function at multiple points.\n    - attribute ``df`` of the result object will be an array of shape ``(n, m)``,\n      the Jacobian.\n    \n    This function is also vectorized in the sense that the Jacobian can be\n    evaluated at ``k`` points in a single call. In this case, `x` would be an\n    array of shape ``(m, k)``, `f` would accept an array of shape\n    ``(m, k, ...)`` and return an array of shape ``(n, k, ...)``, and the ``df``\n    attribute of the result would have shape ``(n, m, k)``.\n    \n    Suppose the desired callable ``f_not_vectorized`` is not vectorized; it can\n    only accept an array of shape ``(m,)``. A simple solution to satisfy the required\n    interface is to wrap ``f_not_vectorized`` as follows::\n    \n        def f(x):\n            return np.apply_along_axis(f_not_vectorized, axis=0, arr=x)\n    \n    Alternatively, suppose the desired callable ``f_vec_q`` is vectorized, but\n    only for 2-D arrays of shape ``(m, q)``. To satisfy the required interface,\n    consider::\n    \n        def f(x):\n            m, batch = x.shape[0], x.shape[1:]  # x.shape is (m, ...)\n            x = np.reshape(x, (m, -1))  # `-1` is short for q = prod(batch)\n            res = f_vec_q(x)  # pass shape (m, q) to function\n            n = res.shape[0]\n            return np.reshape(res, (n,) + batch)  # return shape (n, ...)\n    \n    Then pass the wrapped callable ``f`` as the first argument of `jacobian`.\n    \n    References\n    ----------\n    .. [1] Jacobian matrix and determinant, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant\n    \n    Examples\n    --------\n    The Rosenbrock function maps from :math:`\\mathbf{R}^m \\rightarrow \\mathbf{R}`;\n    the SciPy implementation `scipy.optimize.rosen` is vectorized to accept an\n    array of shape ``(m, p)`` and return an array of shape ``p``. Suppose we wish\n    to evaluate the Jacobian (AKA the gradient because the function returns a scalar)\n    at ``[0.5, 0.5, 0.5]``.\n    \n    >>> import numpy as np\n    >>> from scipy.differentiate import jacobian\n    >>> from scipy.optimize import rosen, rosen_der\n    >>> m = 3\n    >>> x = np.full(m, 0.5)\n    >>> res = jacobian(rosen, x)\n    >>> ref = rosen_der(x)  # reference value of the gradient\n    >>> res.df, ref\n    (array([-51.,  -1.,  50.]), array([-51.,  -1.,  50.]))\n    \n    As an example of a function with multiple outputs, consider Example 4\n    from [1]_.\n    \n    >>> def f(x):\n    ...     x1, x2, x3 = x\n    ...     return [x1, 5*x3, 4*x2**2 - 2*x3, x3*np.sin(x1)]\n    \n    The true Jacobian is given by:\n    \n    >>> def df(x):\n    ...         x1, x2, x3 = x\n    ...         one = np.ones_like(x1)\n    ...         return [[one, 0*one, 0*one],\n    ...                 [0*one, 0*one, 5*one],\n    ...                 [0*one, 8*x2, -2*one],\n    ...                 [x3*np.cos(x1), 0*one, np.sin(x1)]]\n    \n    Evaluate the Jacobian at an arbitrary point.\n    \n    >>> rng = np.random.default_rng(389252938452)\n    >>> x = rng.random(size=3)\n    >>> res = jacobian(f, x)\n    >>> ref = df(x)\n    >>> res.df.shape == (4, 3)\n    True\n    >>> np.allclose(res.df, ref)\n    True\n    \n    Evaluate the Jacobian at 10 arbitrary points in a single call.\n    \n    >>> x = rng.random(size=(3, 10))\n    >>> res = jacobian(f, x)\n    >>> ref = df(x)\n    >>> res.df.shape == (4, 3, 10)\n    True\n    >>> np.allclose(res.df, ref)\n    True",
            "repositoryUrl": "dlg_paletteGen.generated",
            "commitHash": "0.1",
            "paletteDownloadUrl": "",
            "dataHash": "5e28e74b3e79c841faf9da8681918dd21559c529fd41a462027cb8962b01036c",
            "fields": [
                {
                    "id": "5hwc855q",
                    "encoding": "",
                    "name": "f",
                    "value": "",
                    "defaultValue": "",
                    "description": "The function whose Jacobian is desired. The signature must be::\n\n    f(xi: ndarray) -> ndarray\n\nwhere each element of ``xi`` is a finite real. If the function to be\ndifferentiated accepts additional arguments, wrap it (e.g. using\n`functools.partial` or ``lambda``) and pass the wrapped callable\ninto `jacobian`. `f` must not mutate the array ``xi``. See Notes\nregarding vectorization and the dimensionality of the input and output.",
                    "type": "callable",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "olw2qbjf",
                    "encoding": "",
                    "name": "x",
                    "value": "",
                    "defaultValue": "",
                    "description": "Points at which to evaluate the Jacobian. Must have at least one dimension.\nSee Notes regarding the dimensionality and vectorization.",
                    "type": "float arraylike",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "by4ipggk",
                    "encoding": "",
                    "name": "tolerances",
                    "value": "",
                    "defaultValue": "",
                    "description": "Absolute and relative tolerances. Valid keys of the dictionary are:\n\n- ``atol`` - absolute tolerance on the derivative\n- ``rtol`` - relative tolerance on the derivative\n\nIteration will stop when ``res.error < atol + rtol * abs(res.df)``. The default\n`atol` is the smallest normal number of the appropriate dtype, and\nthe default `rtol` is the square root of the precision of the\nappropriate dtype.",
                    "type": "dictionary of floats",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "rci27_p4",
                    "encoding": "",
                    "name": "maxiter",
                    "value": 10,
                    "defaultValue": 10,
                    "description": "The maximum number of iterations of the algorithm to perform. See\nNotes.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "o9fro1mt",
                    "encoding": "",
                    "name": "order",
                    "value": 8,
                    "defaultValue": 8,
                    "description": "The (positive integer) order of the finite difference formula to be\nused. Odd integers will be rounded up to the next even integer.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "lmluyo64",
                    "encoding": "",
                    "name": "initial_step",
                    "value": 0.5,
                    "defaultValue": 0.5,
                    "description": "The (absolute) initial step size for the finite difference derivative\napproximation. Must be broadcastable with `x` and `step_direction`.",
                    "type": "float",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "hy1zwz0c",
                    "encoding": "",
                    "name": "step_factor",
                    "value": 2.0,
                    "defaultValue": 2.0,
                    "description": "The factor by which the step size is *reduced* in each iteration; i.e.\nthe step size in iteration 1 is ``initial_step/step_factor``. If\n``step_factor < 1``, subsequent steps will be greater than the initial\nstep; this may be useful if steps smaller than some threshold are\nundesirable (e.g. due to subtractive cancellation error).",
                    "type": "float",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "nujdc3x0",
                    "encoding": "",
                    "name": "step_direction",
                    "value": 0,
                    "defaultValue": 0,
                    "description": "An array representing the direction of the finite difference steps (e.g.\nfor use when `x` lies near to the boundary of the domain of the function.)\nMust be broadcastable with `x` and `initial_step`.\nWhere 0 (default), central differences are used; where negative (e.g.\n-1), steps are non-positive; and where positive (e.g. 1), all steps are\nnon-negative.",
                    "type": "int",
                    "parameterType": "ApplicationArgument",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "hbnwtc5i",
                    "encoding": "",
                    "name": "func_name",
                    "value": "scipy.differentiate.jacobian",
                    "defaultValue": "scipy.differentiate.jacobian",
                    "description": "Complete import path of function or just a function name which is also used in func_code below.",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "a6dnmiaq",
                    "encoding": "",
                    "name": "log-level",
                    "value": "NOTSET",
                    "defaultValue": "NOTSET",
                    "description": "Log-level to be used for this appplication. If empty or NOTSET, the global setting will be used.",
                    "type": "Select",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [
                        "NOTSET",
                        "DEBUG",
                        "INFO",
                        "WARNING",
                        "ERROR",
                        "CRITICAL"
                    ],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "w8hput28",
                    "encoding": "",
                    "name": "group_start",
                    "value": false,
                    "defaultValue": null,
                    "description": "Is this node the start of a group?",
                    "type": "Boolean",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false,
                    "default_value": false
                },
                {
                    "id": "lyk078fw",
                    "encoding": "",
                    "name": "dropclass",
                    "value": "dlg.apps.pyfunc.PyFuncApp",
                    "defaultValue": "dlg.apps.pyfunc.PyFuncApp",
                    "description": "The python class that implements this application",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "3mroidot",
                    "encoding": "",
                    "name": "base_name",
                    "value": "scipy.differentiate",
                    "defaultValue": "scipy.differentiate",
                    "description": "The base class for this member function.",
                    "type": "String",
                    "parameterType": "ComponentParameter",
                    "usage": "NoPort",
                    "readonly": true,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "xzqzlzr0",
                    "encoding": "",
                    "name": "execution_time",
                    "value": 2,
                    "defaultValue": 2,
                    "description": "Estimate of execution time (in seconds) for this application.",
                    "type": "Integer",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                },
                {
                    "id": "bt3yuwbg",
                    "encoding": "",
                    "name": "num_cpus",
                    "value": 1,
                    "defaultValue": 1,
                    "description": "Number of cores used.",
                    "type": "Integer",
                    "parameterType": "ConstraintParameter",
                    "usage": "NoPort",
                    "readonly": false,
                    "options": [],
                    "precious": false,
                    "positional": false
                }
            ]
        }
    ],
    "linkDataArray": []
}